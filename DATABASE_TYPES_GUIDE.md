# データベース型ガイド

## SQLiteの型システム

SQLiteは**動的型付け**のデータベースで、以下の5つのストレージクラス（型）があります：

### 1. NULL
- 値が存在しないことを表す

### 2. INTEGER
- 符号付き整数
- 1, 2, 3, 4, 6, 8バイトで保存される（値の大きさに応じて）
- 例: `1`, `-100`, `999999`

### 3. REAL
- 浮動小数点数
- 8バイトのIEEE浮動小数点数
- 例: `3.14`, `-0.5`, `1.0e10`

### 4. TEXT
- テキスト文字列
- UTF-8, UTF-16BE, UTF-16LEで保存
- 例: `"Hello"`, `"日本語"`, `"2025-01-01"`

### 5. BLOB
- バイナリデータ
- そのまま保存される
- 例: 画像、ファイルなど

## SQLiteの型宣言

SQLiteでは、CREATE TABLEで型を宣言できますが、**実際には型の制約は緩い**です：

```sql
CREATE TABLE example (
  id INTEGER,        -- 数値として扱われることが多い
  name TEXT,         -- 文字列として扱われることが多い
  value REAL         -- 浮動小数点数として扱われることが多い
);
```

**重要:** SQLiteは型の宣言を「推奨」として扱うだけで、実際には任意の型の値を格納できます。

## このプロジェクトでの型の使い分け

### ✅ TEXT型を使うべきケース

1. **選択肢（Select）**
   - 例: Category, Area, Target, Seller, Status
   - **理由**: 選択肢は文字列として保存し、新しい項目を自由に追加できる
   - **問題なし**: TEXT型で問題ありません

2. **日時（Date/Time）**
   - 例: datetime, date, open, start, end
   - **現状**: TEXT型でISO 8601形式（`2025-01-01T18:00:00Z`）で保存
   - **問題点**: 
     - 日付の比較やソートが文字列比較になる（ただしISO 8601形式なら問題なし）
     - 日付計算ができない（アプリケーション側で処理が必要）
   - **推奨**: 
     - **小規模アプリ**: TEXT型で問題なし（現在の実装）
     - **大規模アプリ**: INTEGER型でUnix timestamp（秒単位）を保存する方が効率的

3. **自由入力のテキスト**
   - 例: title, group, venue, notes, lineup
   - **問題なし**: TEXT型が適切

### ✅ INTEGER型を使うべきケース

1. **数値（金額、数量など）**
   - 例: ticket_fee, drink_fee, fare, fee
   - **理由**: 計算や集計が正確
   - **注意**: SQLiteのINTEGERは整数のみ。小数点が必要な場合はREAL型

2. **フラグ（真偽値）**
   - 例: return_flag
   - **現状**: INTEGER型で0/1を保存
   - **問題なし**: SQLiteにはBOOLEAN型がないため、INTEGERで0/1を使うのが一般的

3. **ID（主キー、外部キー）**
   - 例: id, schedule_id
   - **問題なし**: INTEGER型が適切

### ❌ 使わない型

- **REAL型**: 金額は整数（円単位）で保存するため不要
- **BLOB型**: このプロジェクトでは使用しない

## 日時をTEXT型で保存することについて

### 現在の実装（TEXT型）

```sql
datetime TEXT NOT NULL  -- "2025-01-01T18:00:00Z"
date TEXT               -- "2025-01-01"
open TEXT               -- "17:30"
```

**メリット:**
- ✅ 人間が読みやすい
- ✅ デバッグしやすい
- ✅ ISO 8601形式なら文字列比較でも正しくソートできる
- ✅ タイムゾーン情報を含められる

**デメリット:**
- ❌ 日付計算ができない（アプリケーション側で処理が必要）
- ❌ ストレージサイズが大きい（約20バイト vs 8バイト）
- ❌ インデックスの効率がやや劣る

### 代替案: INTEGER型（Unix timestamp）

```sql
datetime INTEGER NOT NULL  -- 1704110400 (秒単位のUnix timestamp)
```

**メリット:**
- ✅ 日付計算が簡単
- ✅ ストレージサイズが小さい
- ✅ インデックスの効率が良い

**デメリット:**
- ❌ 人間が読みにくい
- ❌ タイムゾーン情報を別途管理する必要がある

### 推奨

**小規模アプリ（現在のプロジェクト）:**
- ✅ **TEXT型で問題なし**
- ISO 8601形式（`YYYY-MM-DDTHH:MM:SSZ`）を使えば、文字列比較でも正しくソート・比較できる
- 可読性が高く、デバッグしやすい

**大規模アプリ:**
- INTEGER型（Unix timestamp）を検討
- ただし、タイムゾーン管理が複雑になる

## 選択肢（Select）の型について

### 質問: 選択肢で自由に作成できる列はTEXT型で良いか？

**答え: ✅ はい、TEXT型で問題ありません**

**理由:**
1. 選択肢は文字列として保存するのが一般的
2. 新しい項目を自由に追加できる
3. データベース側で制約を設ける必要がない
4. アプリケーション側で選択肢リストを管理する

**例:**
```sql
category TEXT  -- "One-man", "Festival", "対バン", "その他" など
area TEXT      -- "東京", "大阪", "愛知" など
```

**注意点:**
- 選択肢の一覧はデータベースではなく、アプリケーション側（フロントエンド）で管理
- 将来的に選択肢を正規化したい場合は、別テーブルを作成することも可能

## 型の選択フローチャート

```
値の種類は？
│
├─ 整数（金額、数量、ID） → INTEGER
│
├─ 浮動小数点数 → REAL（このプロジェクトでは使用しない）
│
├─ 真偽値（0/1） → INTEGER
│
├─ 日時
│   ├─ 小規模アプリ → TEXT（ISO 8601形式）✅ 推奨
│   └─ 大規模アプリ → INTEGER（Unix timestamp）
│
├─ 選択肢（自由に追加可能） → TEXT ✅
│
├─ 自由入力のテキスト → TEXT ✅
│
└─ バイナリデータ → BLOB（このプロジェクトでは使用しない）
```

## まとめ

### このプロジェクトでの推奨

| データの種類 | 型 | 理由 |
|------------|-----|------|
| 選択肢（Category, Area等） | TEXT | 自由に項目追加可能 |
| 日時（datetime, date等） | TEXT | 可読性が高く、ISO 8601形式で問題なし |
| 時刻（open, start等） | TEXT | シンプルで十分 |
| 金額（ticket_fee等） | INTEGER | 計算が正確 |
| フラグ（return_flag） | INTEGER | SQLiteにはBOOLEAN型がないため |
| ID（id, schedule_id） | INTEGER | 標準的 |
| テキスト（title, notes等） | TEXT | 標準的 |

**結論: 現在の実装（TEXT型で日時を保存）で問題ありません！**

